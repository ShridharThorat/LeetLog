Number,Difficulty,Date,Name,Topic,Time,Note
0001,Easy,19-01-25,Two Sum,"['Array', 'Hashtable']",0.33,"Iterate through the array and for each number, add `value, index` pair-since we don't care about which `4` we look at in [1,2,4,4,4]. Also check if the complement exists already, and if so, return the current index and the complement's index. Otherwise return [0,0]."
0104,Easy,27-01-25,Maximum Depth of Binary Tree,"['Tree', 'Depth-first-search', 'Breadth-first-search', 'Binary tree']",0.08,
0003,Medium,06-02-25,Longest Substring Without Repeating Characters,"['Hashtable', 'String', 'Sliding window']",0.67,"One way to do this is to use a queue. While `i` isn't at the end of the string, we can continue to add characters to the queue if the character isn't in the queue. Once we find a repeating character, updating our `max_len`, and then pop the first element in our queue. Once the while-loop is complete, we can update `max_len` once more in case the longest substring extends to the end of the array.<br><br>An alternate technique is to use 2 pointers, `l` and `r` that start off the same. Then while `r` hasn't reached the end, we check if `s[r]` is in the substring `s[l:r]`. If not, we just increment `r`, if it is, we update `max_len`, and move `l` forwards. Similarly in the `queue` technique, we update `max_len` at the end of the loop."
0042,Hard,05-02-25,Trapping Rain Water,"['Array', 'Two pointers', 'Dynamic programming', 'Stack', 'Monotonic stack']",2,"For every block, we know the amount of water that could be stored is the minimum of it's left and right walls. We also know that the left-most block has no left-wall and vice versa for the right-most block.<br>First we can set the <b>current</b> `l_wall` and `r_wall` to `0`, and the loop through our heights. The `maxL[i]` is then our previous wall, which is `l_wall`. Then `l_wall` becomes the maximum of itself, or the current height. The same would go for the `r_wall`, but we'd add values to it in reverse (`j=-i-1`).<br>Finally, the amount of water at each block is the min of it's left and right walls, minus its height -- if this is negative, 0 water is stored.<br><br>A Two pointer approach is possible since we really just need to know the minimum of the left or right--not both. If our `maxL<maxR` then we want to move our left-pointer `l` as well as update our next `maxL` to be the max of itself, and the height at `l`. Then the amt of water here is just the `maxL - height[l]`. If not true, then we do the same thing but for `r` (and `r-=1`)."
